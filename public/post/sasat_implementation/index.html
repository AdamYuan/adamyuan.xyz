<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.71.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>模拟退火求解3-SAT的C&#43;&#43;程序实现&nbsp;&ndash;&nbsp;AdamYuan-&gt;Blog</title><link rel="stylesheet" href="/css/core.min.3fe8a923744e0b66d5312f4346f30c05a93da06d4e65dc0a31c44e27e711d48f55b00fcece6d049f934672a81631dcdf.css" integrity="sha384-P&#43;ipI3ROC2bVMS9DRvMMBak9oG1OZdwKMcROJ&#43;cR1I9VsA/Ozm0En5NGcqgWMdzf"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="模拟退火求解3-SAT的C&#43;&#43;程序实现" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">AdamYuan->Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">模拟退火求解3-SAT的C++程序实现</h1><p class="article date">2019-06-15</p></section><article class="article markdown-body"><h1 id="模拟退火求解3-sat的c程序实现">模拟退火求解3-SAT的C++程序实现</h1>
<h2 id="1-问题概要与求解思路">1. 问题概要与求解思路</h2>
<h3 id="11-3-sat问题">1.1 3-SAT问题</h3>
<p>对于一个形如$$(\overline{x_1} \lor x_2 \lor x_3) \land(x_3 \lor \overline{x_2} \lor \overline{x_4}) \land (x_1 \lor x_2 \lor x_5) \land &hellip; \land (x_{10} \lor \overline{x_{12}} \lor x_{23})$$的布尔表达式。</p>
<p>将布尔条件中一个形如$$(x_1 \lor \overline{x_2} \lor x_4)$$的表达式称为一个括号。对于3-SAT问题，每个括号中只能有3个元素。</p>
<p>定义布尔变量数量为$$N_{var}$$，括号数量为$$N_{clause}$$，3-SAT问题的一个解$$s = (x_1, x_2, &hellip;, x_{N_{var}}), x_k\in{0, 1}$$</p>
<p>3-SAT问题即求解一个$$s$$使布尔表达式为真。这是一个NP完全问题，作为Schaefer&rsquo;s dichotomy定理的一个特例被Thomas Jerome Schaefer证明。</p>
<h3 id="12-模拟退火">1.2 模拟退火</h3>
<p>模拟退火是一个用于求解函数全局最大值的随机算法。与寻常的爬山法不同，模拟退火算法会在邻域内选取一个随机解，是否跳往随机解取决于温度和相对原解的函数值增加量。温度高时，跳转的随机程度大，温度降低后则大概率会跳向邻域内的最优，从而趋向局部最优。这种随机性使算法能够跳出局部最优，更可能寻找到全局最优。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="c1">//typora的latex不支持伪代码，遂用c++代替
</span><span class="c1"></span><span class="n">Solution</span> <span class="nf">SimulatedAnnealing</span><span class="p">(</span><span class="n">Solution</span> <span class="n">s0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Solution</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s0</span><span class="p">;</span> <span class="c1">//s表示当前解，s0为其初始值
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">T</span> <span class="o">=</span> <span class="n">MAX_TEMP</span><span class="p">;</span> <span class="c1">//T为温度
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">T</span> <span class="o">&gt;</span> <span class="n">MIN_TEMP</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">UpdateTemp</span><span class="p">(</span><span class="n">T</span><span class="p">);</span> <span class="c1">//更新(减小)温度
</span><span class="c1"></span>        <span class="n">Solution</span> <span class="n">s_new</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">RandomNeighbour</span><span class="p">();</span> <span class="c1">//从当前解邻域随机选取一个解
</span><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span> <span class="n">P</span><span class="p">(</span> <span class="n">Func</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">Func</span><span class="p">(</span><span class="n">s_new</span><span class="p">),</span> <span class="n">T</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">Random</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">//P()计算接受随机解的概率
</span><span class="c1"></span>            <span class="n">s</span> <span class="o">=</span> <span class="n">s_new</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h3 id="13-sasat算法">1.3 SASAT算法</h3>
<p>本文使用了<strong>SASAT</strong>算法(<strong>William M. Spears, Simulated Annealing for Hard Satisfiability Problems</strong>)。</p>
<p>定义一个3-SAT解的价值$$SAT(s)$$为其能够满足的括号数量，显然若$$SAT(s) = N_{clause}$$，$$s$$则满足了布尔表达式。</p>
<p>对于一个解$$s$$，定义$$Flip(s, n) = (x_1, x_2, &hellip;,\overline{x_n},&hellip;,x_{N_{var}})$$，变换得到的新解构成$$s$$的邻域。</p>
<p>SASAT算法会进行多次模拟退火的尝试，若一次失败，下一次尝试温度下降速率将会变慢，这会降低程序的运行速度，但会增大寻找到满足布尔表达式的解的概率。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">Solution</span> <span class="nf">Try</span><span class="p">(</span><span class="kt">int</span> <span class="n">try_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Solution</span> <span class="n">s</span> <span class="o">=</span> <span class="n">RandomSolution</span><span class="p">();</span> <span class="c1">//随机初始化解
</span><span class="c1"></span>    <span class="kt">double</span> <span class="n">T</span> <span class="o">=</span> <span class="n">MAX_TEMP</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">D</span> <span class="o">=</span> <span class="n">N_VAR</span> <span class="o">*</span> <span class="n">try_id</span><span class="p">;</span> <span class="c1">//D决定了温度的下降速率
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">T</span> <span class="o">&gt;</span> <span class="n">MIN_TEMP</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">SAT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">N_CLAUSE</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">step</span> <span class="o">++</span><span class="p">;</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">UpdateTemp</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">D</span><span class="p">);</span>
        
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N_VAR</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span> <span class="n">P</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Flip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">T</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Random</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">//P()计算接受随机解的概率
</span><span class="c1"></span>            	<span class="n">s</span> <span class="o">=</span> <span class="n">Flip</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">Solution</span> <span class="nf">SASAT</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">try_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">try_id</span> <span class="o">++</span><span class="p">;</span>
        <span class="n">Solution</span> <span class="n">s</span> <span class="o">=</span> <span class="n">Try</span><span class="p">(</span><span class="n">try_id</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">SAT</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="n">N_CLAUSE</span><span class="p">)</span> <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>其中$$UpdateTemp(step, D) = {MAX_TEMP}\cdot e^{{-step} \over D}$$，$$P(s, s_{flip}, T) = ({1 + e^{{SAT(s) - SAT(s_{flip})} \over T} })^{-1}$$</p>
<p>本文侧重于程序的实现，对SASAT算法不继续深究。</p>
<h2 id="2-c程序实现与优化">2. C++程序实现与优化</h2>
<p>(正式进入c++模式)</p>
<h3 id="21-优化sats">2.1 优化SAT(s)</h3>
<h4 id="211-naive">2.1.1 Naive</h4>
<p>SASAT算法的高效执行主要取决于$$SAT(s)$$的运行效率，在$$N_{clause} = 1065$$时，若直接暴力枚举每个括号进行计算，无疑会使运行效率极为低下。$$Flip(s, n)$$在计算机中仅为简单的布尔运算，不会产生这个问题。</p>
<p>暴力枚举的$$SAT(s)$$如下</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">ElementPair</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">var_index</span><span class="p">;</span> <span class="kt">bool</span> <span class="n">nagative</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">Clause</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">clause_index</span><span class="p">;</span> <span class="n">ElementPair</span> <span class="n">elements</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="p">};</span>

<span class="n">Clause</span> <span class="n">clauses</span><span class="p">[</span><span class="n">MAX_CLAUSE_NUM</span><span class="p">];</span><span class="c1">//所有的括号
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">Solution</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">var_value</span><span class="p">[</span><span class="n">MAX_VAR_NUM</span><span class="p">];</span> <span class="c1">//解中每个变量的取值
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">satisfied_cnt</span><span class="p">;</span> <span class="c1">//即SAT(s)
</span><span class="c1"></span>    
    <span class="c1">//以下的函数默认为Solution类的成员函数，即省去了s参数
</span><span class="c1"></span>    <span class="kt">void</span> <span class="nf">Flip</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="p">}</span>
	<span class="kt">bool</span> <span class="nf">ClauseSAT</span><span class="p">(</span><span class="k">const</span> <span class="n">Clause</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
	<span class="p">{</span>
    	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">element</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nagative</span> <span class="o">!=</span> <span class="n">var_value</span><span class="p">[</span> <span class="n">c</span><span class="p">.</span><span class="n">element</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">var_index</span> <span class="p">])</span> <span class="c1">//nagative表示括号中元素对变量取反，var_value为解中各变量的值
</span><span class="c1"></span>            	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="nf">SAT</span><span class="p">()</span>
	<span class="p">{</span>
    	<span class="n">satisfied_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    	<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="n">Clause</span> <span class="o">&amp;</span><span class="nl">c</span> <span class="p">:</span> <span class="n">clauses</span><span class="p">)</span>
        	<span class="k">if</span><span class="p">(</span><span class="n">ClauseSAT</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">++</span><span class="n">satisfied_cnt</span><span class="p">;</span>
    	<span class="k">return</span> <span class="n">satisfied_cnt</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="212-在flip函数中计算sats增减">2.1.2 在Flip函数中计算SAT(s)增减</h4>
<p>通过观察1.2中的伪代码，我们注意到Try函数中s的变换全部通过Flip完成，一个直观的优化是在Flip时统计SAT(s)的增减。</p>
<p>为此我们为每个变量建立一个名为<strong>related_clauses_vec</strong>的列表(std::vector)，记录包含这个变量的括号，当Flip一个变量时，只需要更新列表中的括号便能计算出<strong>SAT(s)</strong>。(需要事先记录每个括号是否满足才能如此更新，称每个括号的满足情况为<strong>clause_value</strong>)</p>
<p>但是直接在Flip中更新SAT(s)也有其问题，若是此变量最终没有被Flip，还得重新把这个变量Flip回来。因此，我们新增两个函数<strong>TestFlip(s, n)<strong>和</strong>ApplyFlip(s)</strong>。<strong>TestFlip(s, n)<strong>在单独的环境中执行修改，记录修改的信息，返回修改后的</strong>SAT(s)</strong>。**ApplyFlip(s)<strong>则将</strong>TestFlip(s, n)**所得的信息覆盖到原来s的信息(<strong>clause_var</strong>, SAT(s), etc..)</p>
<p>进一步优化，对于单个变量，其<strong>related_clauses_vec</strong>可以分为&quot;在括号其中不取反的(<strong>related_clauses_vec[0]</strong>)&ldquo;和&quot;在括号其中取反的(<strong>related_clauses_vec[1]</strong>)&ldquo;两个列表。假设变量从0 Flip成1，**related_clauses_vec[0]<strong>中的括号的值可以直接设为1，而</strong>related_clauses_vec[1]**中的括号则需要调用ClauseSAT进行更新。</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">ElementPair</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">var_index</span><span class="p">;</span> <span class="kt">bool</span> <span class="n">nagative</span><span class="p">;</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">Clause</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">clause_index</span><span class="p">;</span> <span class="n">ElementPair</span> <span class="n">elements</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="p">};</span>

<span class="n">Clause</span> <span class="n">clauses</span><span class="p">[</span><span class="n">MAX_CLAUSE_NUM</span><span class="p">];</span><span class="c1">//所有的括号
</span><span class="c1"></span>
<span class="k">struct</span> <span class="nc">ModifyInfo</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">clause_index</span><span class="p">;</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span> <span class="c1">//新增，为了保存括号值的修改
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">Solution</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">var_value</span><span class="p">[</span><span class="n">MAX_VAR_NUM</span><span class="p">];</span> <span class="c1">//解中每个变量的取值
</span><span class="c1"></span>	<span class="kt">bool</span> <span class="n">clause_value</span><span class="p">[</span><span class="n">MAX_CLAUSE_NUM</span><span class="p">];</span> <span class="c1">//括号是否得到满足
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">satisfied_cnt</span><span class="p">;</span> <span class="c1">//即SAT(s)
</span><span class="c1"></span>    
    <span class="kt">int</span> <span class="n">satisfied_cnt_tmp</span><span class="p">;</span> <span class="c1">//备份的SAT(s)
</span><span class="c1"></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ModifyInfo</span><span class="o">&gt;</span> <span class="n">clause_modifications</span><span class="p">;</span>
    
    <span class="kt">bool</span> <span class="nf">ClauseSAT</span><span class="p">(</span><span class="k">const</span> <span class="n">Clause</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">)</span>
	<span class="p">{</span>
    	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        	<span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">element</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nagative</span> <span class="o">!=</span> <span class="n">var_value</span><span class="p">[</span> <span class="n">c</span><span class="p">.</span><span class="n">element</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">var_index</span> <span class="p">])</span> <span class="c1">//nagative表示括号中元素对变量取反，var_value为解中各变量的值
</span><span class="c1"></span>            	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
    
    <span class="kt">int</span> <span class="nf">TestFlip</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">satisfied_cnt_tmp</span> <span class="o">=</span> <span class="n">satisfied_cnt</span><span class="p">;</span>
		<span class="n">clause_modifications</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Clause</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">related_clauses0</span> <span class="o">=</span> <span class="n">GetRelatedClause</span><span class="p">(</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Clause</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">related_clauses1</span> <span class="o">=</span> <span class="n">GetRelatedClause</span><span class="p">(</span><span class="o">!</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>
		<span class="c1">//获取与变量相关的括号，Flip后related_clauses0中的括号可以直接设为1，而related_clauses1中的括号需要调用ClauseSAT更新
</span><span class="c1"></span>
		<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="n">Clause</span><span class="o">*</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">related_clauses0</span><span class="p">)</span>
			<span class="k">if</span><span class="p">(</span><span class="n">clause_value</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clause_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="c1">//从0变1,才需要更新SAT(s)
</span><span class="c1"></span>			<span class="p">{</span>
				<span class="n">clause_modifications</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clause_index</span><span class="p">,</span> <span class="nb">true</span><span class="p">});</span>
                <span class="c1">//保存修改
</span><span class="c1"></span>				<span class="n">satisfied_cnt_tmp</span> <span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
        
        <span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="n">Clause</span><span class="o">*</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">related_clauses1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">new_clause_value</span> <span class="o">=</span> <span class="n">ClauseSAT</span><span class="p">(</span><span class="o">*</span><span class="n">c</span><span class="p">);</span> <span class="c1">//Flip(n)后括号的值
</span><span class="c1"></span>			<span class="k">if</span><span class="p">(</span><span class="n">clause_value</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clause_index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">new_clause_value</span><span class="p">)</span><span class="c1">//括号值改变则执行修改
</span><span class="c1"></span>			<span class="p">{</span>
				<span class="n">clause_modifications</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clause_index</span><span class="p">,</span> <span class="n">new_clause_value</span><span class="p">});</span>
				<span class="n">satisfied_cnt_tmp</span> <span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
        <span class="p">}</span>
        <span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
		<span class="k">return</span> <span class="n">satisfied_cnt_tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ApplyFlip</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//应用TestFlip的修改
</span><span class="c1"></span>	<span class="p">{</span>
		<span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">clause_modifications</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">ModifyInfo</span> <span class="o">&amp;</span><span class="n">m</span> <span class="o">=</span> <span class="n">clause_modifications</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
            <span class="n">clause_value</span><span class="p">[</span> <span class="n">m</span><span class="p">.</span><span class="n">clause_index</span> <span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
            <span class="n">clause_modifications</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
		<span class="n">satisfied_cnt</span> <span class="o">=</span> <span class="n">satisfied_cnt_tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">int</span> <span class="nf">SAT</span><span class="p">()</span>
	<span class="p">{</span>
    	<span class="k">return</span> <span class="n">satisfied_cnt</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h4 id="213-统计括号中为1的元素个数">2.1.3 统计括号中为1的元素个数</h4>
<p>2.1.2的代码中，<strong>clause_value</strong>数组为布尔类型，仅仅储存括号是否满足，这使得<strong>TestFlip</strong>时能够用到的信息十分有限。为此，我们重新定义<strong>clause_value</strong>为<strong>int</strong>类型，储存括号中为1的元素个数。</p>
<p>假设括号$$c = (x_1 \lor x_2 \lor \overline{x_3})，x_1 = 0, x_2 = 1, x_3 = 0$$，则其<strong>clause_value</strong>为2($$x_2, x_3$$在c中为真)</p>
<p>这样以后，我们可以直接用加、减运算更新<strong>clause_value</strong>，避免了一切<strong>ClauseSAT</strong>调用</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="k">struct</span> <span class="nc">ModifyInfo</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">clause_index</span><span class="p">,</span> <span class="n">value</span><span class="p">;</span> <span class="p">};</span> <span class="c1">//成员value改为int类型
</span><span class="c1"></span>
<span class="k">class</span> <span class="nc">Solution</span>
<span class="p">{</span>
	<span class="kt">bool</span> <span class="n">var_value</span><span class="p">[</span><span class="n">MAX_VAR_NUM</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">clause_value</span><span class="p">[</span><span class="n">MAX_CLAUSE_NUM</span><span class="p">];</span> <span class="c1">//clause_val改为int类型
</span><span class="c1"></span>	<span class="kt">int</span> <span class="n">satisfied_cnt</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">satisfied_cnt_tmp</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ModifyInfo</span><span class="o">&gt;</span> <span class="n">clause_modifications</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="nf">TestFlip</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">satisfied_cnt_tmp</span> <span class="o">=</span> <span class="n">satisfied_cnt</span><span class="p">;</span>
		<span class="n">clause_modifications</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Clause</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">related_clauses0</span> <span class="o">=</span> <span class="n">GetRelatedClause</span><span class="p">(</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Clause</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">related_clauses1</span> <span class="o">=</span> <span class="n">GetRelatedClause</span><span class="p">(</span><span class="o">!</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">n</span><span class="p">);</span>
		<span class="c1">//获取与变量相关的括号，Flip后related_clauses0中的括号可以直接设为1，而related_clauses1中的括号需要调用ClauseSAT更新
</span><span class="c1"></span>
		<span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="n">Clause</span><span class="o">*</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">related_clauses0</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">clause_modifications</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clause_index</span><span class="p">,</span> <span class="mi">1</span><span class="p">});</span> <span class="c1">//给clause_value加1
</span><span class="c1"></span>			<span class="k">if</span><span class="p">(</span><span class="n">clause_value</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clause_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="c1">//从0变1,才需要更新SAT(s)
</span><span class="c1"></span>				<span class="n">satisfied_cnt_tmp</span> <span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
        
        <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="n">Clause</span><span class="o">*</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">related_clauses1</span><span class="p">)</span>
        <span class="p">{</span>
        	<span class="n">clause_modifications</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clause_index</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">});</span>
			<span class="k">if</span><span class="p">(</span><span class="n">clause_value</span><span class="p">[</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clause_index</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">//从1变0
</span><span class="c1"></span>				<span class="n">satisfied_cnt_tmp</span> <span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
		<span class="k">return</span> <span class="n">satisfied_cnt_tmp</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">ApplyFlip</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//应用TestFlip的修改
</span><span class="c1"></span>	<span class="p">{</span>
		<span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">var_value</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">clause_modifications</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">ModifyInfo</span> <span class="o">&amp;</span><span class="n">m</span> <span class="o">=</span> <span class="n">clause_modifications</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
            <span class="n">clause_value</span><span class="p">[</span> <span class="n">m</span><span class="p">.</span><span class="n">clause_index</span> <span class="p">]</span> <span class="o">+=</span> <span class="n">m</span><span class="p">.</span><span class="n">value</span><span class="p">;</span> <span class="c1">//&#34;=&#34;改为&#34;+=&#34;
</span><span class="c1"></span>            <span class="n">clause_modifications</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
		<span class="n">satisfied_cnt</span> <span class="o">=</span> <span class="n">satisfied_cnt_tmp</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div><h3 id="22-多线程">2.2 多线程</h3>
<p>整个SASAT算法包括多次模拟退火的尝试(Try)，很自然的想到将这些尝试并行。可以发现每个Try之间不需要任何数据交换，因此并行十分容易实现。</p>
<p>这是原来的算法框架</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">generator</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span> <span class="c1">//这只是个随机数生成器
</span><span class="c1"></span><span class="n">Solution</span> <span class="nf">solution</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max_tries</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Try</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
		<span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>我们使用了c++11中的<strong>std::future</strong>，<strong>std::async</strong>特性来实现并行</p>
<div class="highlight"><pre class="chroma"><code class="language-c++" data-lang="c++"><span class="kt">unsigned</span> <span class="n">cores</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">future_vector</span><span class="p">;</span>
<span class="n">future_vector</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">cores</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">atomic_int</span> <span class="n">try_id</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">seed_generator</span><span class="p">(</span><span class="n">seed</span><span class="p">);</span>

<span class="k">while</span><span class="p">(</span><span class="n">cores</span> <span class="o">--</span><span class="p">)</span> <span class="c1">//为每个cpu核心创建线程
</span><span class="c1"></span><span class="p">{</span>
	<span class="n">future_vector</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">thread_seed</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span>
				<span class="p">{</span>
					<span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">generator</span><span class="p">(</span><span class="n">thread_seed</span><span class="p">);</span>
					<span class="n">Solution</span> <span class="nf">solution</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

                    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">try_id</span> <span class="o">++</span><span class="p">;</span> <span class="c1">//领取一个Try任务
</span><span class="c1"></span>						<span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">max_tries</span><span class="p">)</span>
							<span class="k">break</span><span class="p">;</span>
	
						<span class="k">if</span><span class="p">(</span><span class="n">Try</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">solution</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>
						<span class="p">{</span>
							<span class="n">try_id</span> <span class="o">=</span> <span class="n">max_tries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//找到满足的解便结束线程
</span><span class="c1"></span>							<span class="k">break</span><span class="p">;</span>
						<span class="p">}</span>
					<span class="p">}</span>
				<span class="p">},</span> <span class="n">seed_generator</span><span class="p">()</span> <span class="c1">//为每个线程传入随机种子
</span><span class="c1"></span>	<span class="p">));</span>
<span class="p">}</span>
</code></pre></div><h3 id="23-分析与比较">2.3 分析与比较</h3>
<p>测试数据中$$N_{var} = 250, N_{clause} = 1065$$</p>
<p>测试环境为Manjaro 18.0.4 Illyria，x86_64 Linux 5.0.21-1-MANJARO，Intel Xeon E3-1505M v6 @ 8x 4GHz，gcc (GCC) 8.3.0</p>
<p>编译参数为-Ofast -funsafe-loop-optimizations -lpthread</p>
<table>
<thead>
<tr>
<th>3-SAT数据</th>
<th>随机种子</th>
<th>Try次数</th>
<th>2.1.1 Naive</th>
<th>2.1.2 优化1</th>
<th>2.1.3 优化2</th>
</tr>
</thead>
<tbody>
<tr>
<td>uf250-03.cnf</td>
<td>1</td>
<td>25</td>
<td>460.137443秒</td>
<td>4.6562805秒</td>
<td>3.0755805秒</td>
</tr>
<tr>
<td>uf250-07.cnf</td>
<td>3643878294</td>
<td>8</td>
<td>47.531635秒</td>
<td>0.509907秒</td>
<td>0.343409秒</td>
</tr>
</tbody>
</table>
<p>多线程由于各线程的竞争关系，引入了更多的随机性，同一随机种子的运行时间可能大不相同，这里通过相同Try次数的运行时间进行比较。</p>
<table>
<thead>
<tr>
<th>3-SAT数据</th>
<th>Try次数</th>
<th>2.1.2优化1</th>
<th>2.1.2优化1 + 8线程</th>
<th>2.1.3优化2</th>
<th>2.1.3优化2 + 8线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>uf250-03.cnf</td>
<td>25</td>
<td>4.6562805秒</td>
<td>0.690253秒(6.74倍)</td>
<td>3.0755805秒</td>
<td>0.504293秒(6.1倍)</td>
</tr>
<tr>
<td>uf250-02.cnf</td>
<td>30</td>
<td>6.579755秒</td>
<td>0.967821秒(6.8倍)</td>
<td>4.6801452秒</td>
<td>0.852714秒(5.49倍)</td>
</tr>
</tbody>
</table>
<p>可见多线程对于运行效率的提升是显著的，对于<strong>2.1.2优化1</strong>的提升会更大一些。由于SASAT算法本身的优良特性，大多数情况下Try次数都在30以内，此程序多能在1秒内求解。</p>
<h2 id="附录">附录</h2>
<p>测试样例详见<a href="https://github.com/AdamYuan/SATv2/tree/master/problems">https://github.com/AdamYuan/SATv2/tree/master/problems</a></p>
<p><strong>2.1.3优化2 + 多线程</strong> 程序<a href="https://github.com/AdamYuan/SATv2">https://github.com/AdamYuan/SATv2</a></p></article><section class="article labels"><a class="category" href=/categories/%E7%AE%97%E6%B3%95/>算法</a><a class="tag" href=/tags/np%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98/>NP完全问题</a></section><section class="article author"><img class="avatar" src="/img/avatar.png" alt><p class="name">AdamYuan</p><div class="details"><a class="item" href="https://github.com/AdamYuan" target="_blank"><span class="iconfont icon-github"></span>&nbsp;AdamYuan</a><a class="item" href="mailto:y13916619121@126.com" target="_blank"><span class="iconfont icon-email"></span>&nbsp;y13916619121@126.com</a></div>
</section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/post/big_pow/"><span class="iconfont icon-article"></span>计算3的1000000次方</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2019 AdamYuan.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script></body>

</html>