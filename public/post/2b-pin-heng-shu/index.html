<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>二逼平衡树(splay / vector &#43; 线段树) - AdamYuan-&gt;Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="AdamYuan" />
  <meta name="description" content="题目概述 您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：
1. 查询k在区间内的排名
2. 查询区间内排名为k的值
3. 修改某一位值上的数值
4. 查询k在区间内的前驱（前驱定义为严格小于x，且最大的数，若不存在输出-2147483647）
5. 查询k在区间内的后继（后继定义为严格大于x，且最小的数，若不存在输出2147483647）
" />







<meta name="generator" content="Hugo 0.44" />


<link rel="canonical" href="https://adamyuan.xyz/post/2b-pin-heng-shu/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="二逼平衡树(splay / vector &#43; 线段树)" />
<meta property="og:description" content="题目概述

您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：
1. 查询k在区间内的排名
2. 查询区间内排名为k的值
3. 修改某一位值上的数值
4. 查询k在区间内的前驱（前驱定义为严格小于x，且最大的数，若不存在输出-2147483647）
5. 查询k在区间内的后继（后继定义为严格大于x，且最小的数，若不存在输出2147483647）
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://adamyuan.xyz/post/2b-pin-heng-shu/" />



<meta property="article:published_time" content="2018-09-27T21:21:54&#43;08:00"/>

<meta property="article:modified_time" content="2018-09-27T21:21:54&#43;08:00"/>











<meta itemprop="name" content="二逼平衡树(splay / vector &#43; 线段树)">
<meta itemprop="description" content="题目概述

您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：
1. 查询k在区间内的排名
2. 查询区间内排名为k的值
3. 修改某一位值上的数值
4. 查询k在区间内的前驱（前驱定义为严格小于x，且最大的数，若不存在输出-2147483647）
5. 查询k在区间内的后继（后继定义为严格大于x，且最小的数，若不存在输出2147483647）
">


<meta itemprop="datePublished" content="2018-09-27T21:21:54&#43;08:00" />
<meta itemprop="dateModified" content="2018-09-27T21:21:54&#43;08:00" />
<meta itemprop="wordCount" content="3489">



<meta itemprop="keywords" content="树套树,splay,线段树,vector," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="二逼平衡树(splay / vector &#43; 线段树)"/>
<meta name="twitter:description" content="题目概述

您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：
1. 查询k在区间内的排名
2. 查询区间内排名为k的值
3. 修改某一位值上的数值
4. 查询k在区间内的前驱（前驱定义为严格小于x，且最大的数，若不存在输出-2147483647）
5. 查询k在区间内的后继（后继定义为严格大于x，且最小的数，若不存在输出2147483647）
"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">AdamYuan-&gt;Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">AdamYuan-&gt;Blog</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">二逼平衡树(splay / vector &#43; 线段树)</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-09-27 </span>
        <div class="post-category">
            
              <a href="/categories/oi/"> OI </a>
            
          </div>
        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#题目概述">题目概述</a></li>
<li><a href="#基本思路">基本思路</a></li>
<li><a href="#吐槽">吐槽</a></li>
<li><a href="#代码">代码</a>
<ul>
<li><a href="#std-vector版-ac">std::vector版（AC）</a></li>
<li><a href="#splay版-tle-70">splay版（TLE 70%）</a></li>
<li><a href="#无旋treap-tle-70">无旋treap（TLE 70%）</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <h1 id="题目概述">题目概述</h1>

<p>您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：<br />
1. 查询k在区间内的排名<br />
2. 查询区间内排名为k的值<br />
3. 修改某一位值上的数值<br />
4. 查询k在区间内的前驱（前驱定义为严格小于x，且最大的数，若不存在输出-2147483647）<br />
5. 查询k在区间内的后继（后继定义为严格大于x，且最小的数，若不存在输出2147483647）<br />
</p>

<h1 id="基本思路">基本思路</h1>

<p>这是一道树套树（线段树套平衡树）的模板题，下面讲解一下5个操作的写法：<br />
1. 分别查询区间对应的每个平衡树中k元素的排名，再相加<br />
2. 这个是最难想的，其实就是二分答案。。。可以线段树里再维护最大最小值加速二分<br />
3. 就是插入+删除<br />
4. 分别查询每颗平衡树中k的前驱，取最大<br />
5. 分别查询每颗平衡树中k的后继，取最小</p>

<p>操作3的复杂度为 \begin{equation} \log^3(n) \end{equation}
其它为 \begin{equation} \log^2(n) \end{equation}</p>

<h1 id="吐槽">吐槽</h1>

<p>这题竟然可以线段树套std::vector水过，然而splay却会TLE 3个点。。。</p>

<h1 id="代码">代码</h1>

<h2 id="std-vector版-ac">std::vector版（AC）</h2>

<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

#define N 50005
#define MINV -2147483647
#define MAXV 2147483647

int arr[N];

inline int vec_query_rank(const std::vector&lt;int&gt; &amp;vec, int x) { return std::lower_bound(vec.begin(), vec.end(), x) - vec.begin(); }
inline int vec_query_prev(const std::vector&lt;int&gt; &amp;vec, int x) 
{
	std::vector&lt;int&gt;::const_iterator i = std::lower_bound(vec.begin(), vec.end(), x);
	if(i == vec.begin()) return MINV;
	return *(i-1);
}
inline int vec_query_next(const std::vector&lt;int&gt; &amp;vec, int x) 
{
	std::vector&lt;int&gt;::const_iterator i = std::upper_bound(vec.begin(), vec.end(), x);
	if(i == vec.end()) return MAXV;
	return *i;
}
inline void vec_modify(std::vector&lt;int&gt; *vec, int newval, int oldval)
{
	vec-&gt;erase(std::lower_bound(vec-&gt;begin(), vec-&gt;end(), oldval));
	vec-&gt;insert(std::lower_bound(vec-&gt;begin(), vec-&gt;end(), newval), newval);
}

namespace seg
{
	struct Node
	{
		std::vector&lt;int&gt; vec;
		Node *lson, *rson;
		int l, r, rmin, rmax;
	};

	Node node_pool[N &lt;&lt; 2], *segroot;

	inline Node *new_node() { static Node *p = node_pool; p-&gt;lson = p-&gt;rson = NULL; return p++; }

	inline void pushup(Node *node)
	{
		node-&gt;rmax = std::max(node-&gt;lson ? node-&gt;lson-&gt;rmax : MINV, node-&gt;rson ? node-&gt;rson-&gt;rmax : MINV);
		node-&gt;rmin = std::min(node-&gt;lson ? node-&gt;lson-&gt;rmin : MAXV, node-&gt;rson ? node-&gt;rson-&gt;rmin : MAXV);
	}
	int sort_tmp[N];
	Node *build_tree(int l, int r)
	{
		Node *current; int mid, sz;

		current = new_node();
		current-&gt;l = l; 
		current-&gt;r = r;

		if(l != r)
		{
			mid = (l + r) &gt;&gt; 1;
			current-&gt;lson = build_tree(l, mid);
			current-&gt;rson = build_tree(mid + 1, r);
			pushup(current);

			sz = r-l+1;

			//merge sort
			current-&gt;vec.resize(sz);
			std::merge(sort_tmp + l, sort_tmp + mid + 1, sort_tmp + mid + 1, sort_tmp + r + 1, current-&gt;vec.begin());
			std::copy(current-&gt;vec.begin(), current-&gt;vec.end(), sort_tmp + l);
		}
		else
		{
			sort_tmp[l] = arr[l];
			current-&gt;rmin = current-&gt;rmax = arr[l];

			//create vector with 1 element
			current-&gt;vec.push_back(arr[l]);
		}

		return current;
	}

	void query_bound(Node *node, int l, int r, int *rmin, int *rmax) //should first initialize rmin and rmax with MAXV and MINV
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
		{
			*rmin = std::min(*rmin, node-&gt;rmin);
			*rmax = std::max(*rmax, node-&gt;rmax);
		}
		else
		{
			query_bound(node-&gt;lson, l, r, rmin, rmax);
			query_bound(node-&gt;rson, l, r, rmin, rmax);
		}
	}

	int query_rank(Node *node, int l, int r, int x) //return number of value smaller than x
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return 0;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return vec_query_rank(node-&gt;vec, x);
		else
			return query_rank(node-&gt;lson, l, r, x) + query_rank(node-&gt;rson, l, r, x);
	}

	int query_kth(int l, int r, int k) //k &gt;= 1
	{
		static int rmin, rmax, low, high, mid, midrk;

		rmin = MAXV, rmax = MINV;
		query_bound(segroot, l, r, &amp;rmin, &amp;rmax);

		//binary search
		low = rmin; high = rmax;
		while(low != high)
		{
			mid = (low + high + 1) &gt;&gt; 1; 
			midrk = query_rank(segroot, l, r, mid) + 1;
			if(midrk &lt;= k) low = mid;
			else high = mid - 1;
		}
		return low;
	}

	int query_prev(Node *node, int l, int r, int x) 
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return MINV;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return vec_query_prev(node-&gt;vec, x);
		else
			return std::max(query_prev(node-&gt;lson, l, r, x), query_prev(node-&gt;rson, l, r, x));
	}

	int query_next(Node *node, int l, int r, int x) 
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return MAXV;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return vec_query_next(node-&gt;vec, x);
		else
			return std::min(query_next(node-&gt;lson, l, r, x), query_next(node-&gt;rson, l, r, x));
	}

	void modify(Node *node, int pos, int x, int old)
	{
		vec_modify(&amp;node-&gt;vec, x, old);

		if(node-&gt;l != node-&gt;r)
		{
			if(pos &lt;= ((node-&gt;l + node-&gt;r) &gt;&gt; 1))
				modify(node-&gt;lson, pos, x, old);
			else modify(node-&gt;rson, pos, x, old);

			pushup(node);
		}
		else
			node-&gt;rmax = node-&gt;rmin = x;
	}
}

int main()
{
	int n, m;
	scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%d&quot;, &amp;m);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, arr + i);
	seg::segroot = seg::build_tree(1, n);

	int opt, l, r, k, pos;
	while(m --)
	{
		scanf(&quot;%d&quot;, &amp;opt);
		if(opt == 1)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_rank(seg::segroot, l, r, k) + 1);
		}
		else if(opt == 2)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_kth(l, r, k));
		}
		else if(opt == 3)
		{
			scanf(&quot;%d%d&quot;, &amp;pos, &amp;k);
			seg::modify(seg::segroot, pos, k, arr[pos]);
			arr[pos] = k;
		}
		else if(opt == 4)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_prev(seg::segroot, l, r, k));
		}
		else
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_next(seg::segroot, l, r, k));
		}
	}

	return 0;
}
</code></pre>

<h2 id="splay版-tle-70">splay版（TLE 70%）</h2>

<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

#define N 50005
#define MINV -2147483647
#define MAXV 2147483647

int arr[N];
namespace splay
{
	struct Node
	{
		Node *parent;
		union { struct {Node *lson, *rson; }; Node *son[2]; };
		int count, size, value;
	} node_pool[N &lt;&lt; 7];

	inline Node *new_node() { static Node *p = node_pool; p-&gt;lson = p-&gt;rson = p-&gt;parent = NULL; return p++; }
	inline bool which_son(Node *node) { return node-&gt;parent-&gt;rson == node; }
	inline void pushup(Node *node)
	{
		node-&gt;size = node-&gt;count;
		if(node-&gt;lson) node-&gt;size += node-&gt;lson-&gt;size;
		if(node-&gt;rson) node-&gt;size += node-&gt;rson-&gt;size;
	}
	inline void rotate(Node **root, Node *node)
	{
		static bool a, b; static Node *mov, *fa, *gfa;
		fa = node-&gt;parent;
		a = which_son(node); b = !a;
		mov = node-&gt;son[b]; fa-&gt;son[a] = mov; if(mov) mov-&gt;parent = fa;

		gfa = fa-&gt;parent;
		(gfa ? gfa-&gt;son[which_son(fa)] : *root) = node; node-&gt;parent = gfa;

		node-&gt;son[b] = fa; fa-&gt;parent = node;

		pushup(fa); pushup(node);
	}
	inline void splay(Node **root, Node *node, Node *target)
	{
		static Node *fa, *gfa;
		while((fa = node-&gt;parent) != target)
		{
			gfa = fa-&gt;parent;
			if(gfa != target)
				rotate(root, which_son(node) == which_son(fa) ? fa : node);
			rotate(root, node);
		}
	}
	void print(Node *node)
	{
		if(!node) return;
		print(node-&gt;lson);
		printf(&quot;%d %d; &quot;, node-&gt;value, node-&gt;count);
		print(node-&gt;rson);
	}
	inline Node *find(Node **root, int x)
	{
		static Node *current;
		current = *root;
		while(current &amp;&amp; current-&gt;value != x)
			if(x &lt; current-&gt;value) current = current-&gt;lson;
			else current = current-&gt;rson;
		if(current) splay(root, current, NULL);
		return current;
	}
	inline void find_target(Node **root, int x, Node ***target, Node **father) 
		//return pointer of node to be inserted and its parent
	{
		*target = root;
		while(**target)
		{
			*father = **target;
			if(x &lt; (**target)-&gt;value) *target = &amp;((**target)-&gt;lson);
			else *target = &amp;((**target)-&gt;rson);
		}
	}
	inline Node *query_max(Node *root) //get max value in a tree
	{
		while(root-&gt;rson)
			root = root-&gt;rson;
		return root;
	}
	inline Node *query_min(Node *root) //get min value in a tree
	{
		while(root-&gt;lson)
			root = root-&gt;lson;
		return root;
	}
	inline Node *insert(Node **root, int x)
	{
		static Node *f;
		f = find(root, x);
		if(f) { f-&gt;count ++; f-&gt;size ++; }
		else
		{
			Node **target, *father;
			find_target(root, x, &amp;target, &amp;father);
			(*target) = new_node(); (*target)-&gt;value = x; 
			(*target)-&gt;count = (*target)-&gt;size = 1; (*target)-&gt;parent = father;
			splay(root, *target, NULL);
		}
		return *root;
	}
	inline void erase(Node **root, int x)
	{
		static Node *f, *m;
		f = find(root, x);
		if(!f) return;
		if(--f-&gt;count &amp;&amp; --f-&gt;size) return;
		//f is the root now
		if(f-&gt;lson)
		{
			m = query_max(f-&gt;lson);
			splay(root, m, f);
			m-&gt;parent = NULL; 
			m-&gt;rson = f-&gt;rson; if(f-&gt;rson) { m-&gt;rson-&gt;size += f-&gt;rson-&gt;size; f-&gt;rson-&gt;parent = m; }
			*root = m;
		}
		else //left son is empty, let rson be the root
		{
			*root = (*root)-&gt;rson;
			(*root)-&gt;parent = NULL;
		}
	}
	inline int query_rank(Node **root, int x) //return number of value smaller than x
	{
		static bool exist;
		exist = find(root, x);
		if(!exist) insert(root, x);
		int val = (*root)-&gt;lson ? (*root)-&gt;lson-&gt;size : 0;
		if(!exist) erase(root, x);
		return val;
	}
	inline int query_prev(Node **root, int x) //return the biggest value smaller than x
	{
		static bool exist;
		exist = find(root, x);
		if(!exist) insert(root, x); //the new node is the root
		int val = (*root)-&gt;lson ? query_max((*root)-&gt;lson)-&gt;value : MINV;
		if(!exist) erase(root, x); //the new node is the root
		return val;
	}
	inline int query_next(Node **root, int x)
	{
		static bool exist;
		exist = find(root, x);
		if(!exist) insert(root, x);
		int val = (*root)-&gt;rson ? query_min((*root)-&gt;rson)-&gt;value : MAXV;
		if(!exist) erase(root, x);
		return val;
	}
	Node *build_tree(int *value_arr, int *cnt_arr, Node *father, int l, int r)
	{
		if(l &gt; r) return NULL;

		int mid = (l + r) &gt;&gt; 1;
		Node *current = new_node(); 
		current-&gt;parent = father;
		current-&gt;value = value_arr[mid];
		current-&gt;count = cnt_arr[mid];
		current-&gt;lson = build_tree(value_arr, cnt_arr, current, l, mid - 1);
		current-&gt;rson = build_tree(value_arr, cnt_arr, current, mid + 1, r);

		pushup(current);

		return current;
	}
}

namespace seg
{
	struct Node
	{
		splay::Node *root;
		Node *lson, *rson;
		int l, r, rmin, rmax;
	};

	Node node_pool[N &lt;&lt; 2], *segroot;

	inline Node *new_node() { static Node *p = node_pool; p-&gt;lson = p-&gt;rson = NULL; return p++; }

	inline void pushup(Node *node)
	{
		node-&gt;rmax = std::max(node-&gt;lson ? node-&gt;lson-&gt;rmax : MINV, node-&gt;rson ? node-&gt;rson-&gt;rmax : MINV);
		node-&gt;rmin = std::min(node-&gt;lson ? node-&gt;lson-&gt;rmin : MAXV, node-&gt;rson ? node-&gt;rson-&gt;rmin : MAXV);
	}
	int sort_tmp[N], merge_tmp[N], cnt_tmp[N];
	Node *build_tree(int l, int r)
	{
		Node *current; int mid, sz, total;

		current = new_node();
		current-&gt;l = l; 
		current-&gt;r = r;

		if(l != r)
		{
			mid = (l + r) &gt;&gt; 1;
			current-&gt;lson = build_tree(l, mid);
			current-&gt;rson = build_tree(mid + 1, r);
			pushup(current);

			sz = r-l+1;

			//merge sort
			std::merge(sort_tmp + l, sort_tmp + mid + 1, sort_tmp + mid + 1, sort_tmp + r + 1, merge_tmp + 1);
			std::copy(merge_tmp + 1, merge_tmp + sz+1, sort_tmp + l);

			total = 0;
			for(int i = 1; i &lt;= sz; ++i) //make the array(for building tree) unique and get the count
				if(i == 1 || merge_tmp[i] != merge_tmp[i-1])
				{
					++total;
					merge_tmp[total] = merge_tmp[i];
					cnt_tmp[total] = 1;
				}
				else cnt_tmp[total] ++;

			//build balanced tree
			current-&gt;root = splay::build_tree(merge_tmp, cnt_tmp, NULL, 1, total);
		}
		else
		{
			sort_tmp[l] = arr[l];
			current-&gt;rmin = current-&gt;rmax = arr[l];

			//create tree with 1 element
			current-&gt;root = splay::new_node();
			current-&gt;root-&gt;value = arr[l];
			current-&gt;root-&gt;size = current-&gt;root-&gt;count = 1;
		}

		return current;
	}

	void query_bound(Node *node, int l, int r, int *rmin, int *rmax) //should first initialize rmin and rmax with MAXV and MINV
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
		{
			*rmin = std::min(*rmin, node-&gt;rmin);
			*rmax = std::max(*rmax, node-&gt;rmax);
		}
		else
		{
			query_bound(node-&gt;lson, l, r, rmin, rmax);
			query_bound(node-&gt;rson, l, r, rmin, rmax);
		}
	}

	int query_rank(Node *node, int l, int r, int x) //return number of value smaller than x
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return 0;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return splay::query_rank(&amp;node-&gt;root, x);
		else
			return query_rank(node-&gt;lson, l, r, x) + query_rank(node-&gt;rson, l, r, x);
	}

	int query_kth(int l, int r, int k) //k &gt;= 1
	{
		static int rmin, rmax, low, high, mid, midrk;

		rmin = MAXV, rmax = MINV;
		query_bound(segroot, l, r, &amp;rmin, &amp;rmax);

		//binary search
		low = rmin; high = rmax;
		while(low != high)
		{
			mid = (low + high + 1) &gt;&gt; 1; 
			midrk = query_rank(segroot, l, r, mid) + 1;
			if(midrk &lt;= k) low = mid;
			else high = mid - 1;
		}
		return low;
	}

	int query_prev(Node *node, int l, int r, int x) 
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return MINV;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return splay::query_prev(&amp;node-&gt;root, x);
		else
			return std::max(query_prev(node-&gt;lson, l, r, x), query_prev(node-&gt;rson, l, r, x));
	}

	int query_next(Node *node, int l, int r, int x) 
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return MAXV;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return splay::query_next(&amp;node-&gt;root, x);
		else
			return std::min(query_next(node-&gt;lson, l, r, x), query_next(node-&gt;rson, l, r, x));
	}

	void modify(Node *node, int pos, int x, int old)
	{
		splay::insert(&amp;node-&gt;root, x);
		splay::erase(&amp;node-&gt;root, old);

		if(node-&gt;l != node-&gt;r)
		{
			if(pos &lt;= ((node-&gt;l + node-&gt;r) &gt;&gt; 1))
				modify(node-&gt;lson, pos, x, old);
			else modify(node-&gt;rson, pos, x, old);

			pushup(node);
		}
		else
			node-&gt;rmax = node-&gt;rmin = x;
	}
}

int main()
{
	int n, m;
	scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%d&quot;, &amp;m);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, arr + i);
	seg::segroot = seg::build_tree(1, n);

	int opt, l, r, k, pos;
	while(m --)
	{
		scanf(&quot;%d&quot;, &amp;opt);
		if(opt == 1)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_rank(seg::segroot, l, r, k) + 1);
		}
		else if(opt == 2)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_kth(l, r, k));
		}
		else if(opt == 3)
		{
			scanf(&quot;%d%d&quot;, &amp;pos, &amp;k);
			seg::modify(seg::segroot, pos, k, arr[pos]);
			arr[pos] = k;
		}
		else if(opt == 4)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_prev(seg::segroot, l, r, k));
		}
		else
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_next(seg::segroot, l, r, k));
		}
	}

	return 0;
}
</code></pre>

<h2 id="无旋treap-tle-70">无旋treap（TLE 70%）</h2>

<pre><code class="language-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;random&gt;

#define N 50005
#define MINV -2147483647
#define MAXV 2147483647

int arr[N];

namespace treap
{
	struct Node
	{
		union { struct {Node *lson, *rson; }; Node *son[2]; };
		int count, size, value, rndkey;
	} node_pool[N &lt;&lt; 7];

	std::random_device rd{};
	std::mt19937 gen{rd()};
	inline Node *new_node() { static Node *p = node_pool; p-&gt;lson = p-&gt;rson = NULL; p-&gt;rndkey = gen(); return p++; }
	inline void maintain(Node *node)
	{
		node-&gt;size = node-&gt;count;
		if(node-&gt;lson) node-&gt;size += node-&gt;lson-&gt;size;
		if(node-&gt;rson) node-&gt;size += node-&gt;rson-&gt;size;
	}
	void print(Node *node)
	{
		if(!node) return;
		print(node-&gt;lson);
		printf(&quot;%d %d; &quot;, node-&gt;value, node-&gt;count);
		print(node-&gt;rson);
	}
	Node *init()
	{
		Node *l = new_node(); l-&gt;size = l-&gt;count = 0; l-&gt;value = MINV;
		Node *r = new_node(); r-&gt;size = r-&gt;count = 0; r-&gt;value = MAXV;
		if(l-&gt;rndkey &lt; r-&gt;rndkey) { l-&gt;rson = r; return l; } //keep l as root
		r-&gt;lson = l; return r;
	}
	Node *merge(Node *l, Node *r)
	{
		if(l == NULL) return r;
		if(r == NULL) return l;
		if(l-&gt;rndkey &lt; r-&gt;rndkey) //keep l as root
		{
			l-&gt;rson = merge(l-&gt;rson, r);
			maintain(l); return l;
		}
		r-&gt;lson = merge(l, r-&gt;lson);
		maintain(r); return r;
	}
	void split(Node *root, int x, Node **l, Node **r)
	{
		if(root == NULL) { *l = *r = nullptr; return; }
		if(root-&gt;value &lt; x)
		{
			*l = root;
			split(root-&gt;rson, x, &amp;(root-&gt;rson), r);
		}
		else
		{
			*r = root;
			split(root-&gt;lson, x, l, &amp;(root-&gt;lson));
		}
		maintain(root);
	}
	inline Node *find(Node *root, int x)
	{
		while(root &amp;&amp; root-&gt;value != x)
			if(x &lt; root-&gt;value) root = root-&gt;lson;
			else root = root-&gt;rson;
		return root;
	}
	void pushup_size(Node *root, int x, int plus) //ensure find(root, x)
	{
		root-&gt;size += plus;
		if(root-&gt;value != x)
		{
			if(x &lt; root-&gt;value) pushup_size(root-&gt;lson, x, plus);
			else pushup_size(root-&gt;rson, x, plus);
		}
	}
	inline Node *query_max(Node *root) //get max value in a tree
	{
		while(root-&gt;rson)
			root = root-&gt;rson;
		return root;
	}
	inline Node *query_min(Node *root) //get min value in a tree
	{
		while(root-&gt;lson)
			root = root-&gt;lson;
		return root;
	}
	inline void insert(Node **root, int x) //return root
	{
		Node *f = find(*root, x);
		if(f)
		{
			f-&gt;count ++;
			pushup_size(*root, x, 1);
		}
		else
		{
			Node *l, *r;
			split(*root, x, &amp;l, &amp;r); //[MINV, x) and [x, MAXV]
			Node *ins = new_node();
			ins-&gt;count = ins-&gt;size = 1;
			ins-&gt;value = x;

			*root = merge(merge(l, ins), r);
		}
	}
	inline void erase(Node **root, int x)
	{
		Node *f = find(*root, x);
		f-&gt;count --;
		pushup_size(*root, x, -1);

		if(f-&gt;count) return;

		Node *l, *r, *rl, *rr;
		split(*root, x, &amp;l, &amp;r); //[MINV, x)
		split(r, x + 1, &amp;rl, &amp;rr);

		*root = merge(l, rr);
	}
	inline int query_rank(Node **root, int x) //return number of value smaller than x
	{
		static Node *l, *r;
		split(*root, x, &amp;l, &amp;r);
		int val = l-&gt;size;
		*root = merge(l, r);
		return val;
	}
	inline int query_prev(Node **root, int x) //return the biggest value smaller than x
	{
		static Node *l, *r;
		split(*root, x, &amp;l, &amp;r);
		int val = query_max(l)-&gt;value;
		*root = merge(l, r);
		return val;
	}
	inline int query_next(Node **root, int x)
	{
		static Node *l, *r;
		split(*root, x + 1, &amp;l, &amp;r);
		int val = query_min(r)-&gt;value;
		*root = merge(l, r);
		return val;
	}
}

namespace seg
{
	struct Node
	{
		treap::Node *root;
		Node *lson, *rson;
		int l, r, rmin, rmax;
	};

	Node node_pool[N &lt;&lt; 2], *segroot;

	inline Node *new_node() { static Node *p = node_pool; p-&gt;lson = p-&gt;rson = NULL; return p++; }

	inline void pushup(Node *node)
	{
		node-&gt;rmax = std::max(node-&gt;lson ? node-&gt;lson-&gt;rmax : MINV, node-&gt;rson ? node-&gt;rson-&gt;rmax : MINV);
		node-&gt;rmin = std::min(node-&gt;lson ? node-&gt;lson-&gt;rmin : MAXV, node-&gt;rson ? node-&gt;rson-&gt;rmin : MAXV);
	}

	Node *build_empty_tree(int l, int r)
	{
		Node *current;

		current = new_node();
		current-&gt;l = l; 
		current-&gt;r = r;
		//create tree with 2 element (MAXV &amp; MINV)
		current-&gt;root = treap::init();

		if(l != r)
		{
			int mid = (l + r) &gt;&gt; 1;
			current-&gt;lson = build_empty_tree(l, mid);
			current-&gt;rson = build_empty_tree(mid + 1, r);
			pushup(current);
		}
		else
			current-&gt;rmin = current-&gt;rmax = arr[l];

		return current;
	}

	inline void build_tree(int l, int r)
	{
		segroot = build_empty_tree(l, r);

		Node *current;
		for(int i = l; i &lt;= r; ++i)
		{
			current = segroot;
			while(current)
			{
				treap::insert(&amp;current-&gt;root, arr[i]);
				current = i &lt;= ((current-&gt;l + current-&gt;r) &gt;&gt; 1) ? current-&gt;lson : current-&gt;rson;
			}
		}
	}

	void query_bound(Node *node, int l, int r, int *rmin, int *rmax) //should first initialize rmin and rmax with MAXV and MINV
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
		{
			*rmin = std::min(*rmin, node-&gt;rmin);
			*rmax = std::max(*rmax, node-&gt;rmax);
		}
		else
		{
			query_bound(node-&gt;lson, l, r, rmin, rmax);
			query_bound(node-&gt;rson, l, r, rmin, rmax);
		}
	}

	int query_rank(Node *node, int l, int r, int x) //return number of value smaller than x
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return 0;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return treap::query_rank(&amp;node-&gt;root, x);
		else
			return query_rank(node-&gt;lson, l, r, x) + query_rank(node-&gt;rson, l, r, x);
	}

	int query_kth(int l, int r, int k) //k &gt;= 1
	{
		static int rmin, rmax, low, high, mid, midrk;

		rmin = MAXV, rmax = MINV;
		query_bound(segroot, l, r, &amp;rmin, &amp;rmax);

		//binary search
		low = rmin; high = rmax;
		while(low != high)
		{
			mid = (low + high + 1) &gt;&gt; 1; 
			midrk = query_rank(segroot, l, r, mid) + 1;
			if(midrk &lt;= k) low = mid;
			else high = mid - 1;
		}
		return low;
	}

	int query_prev(Node *node, int l, int r, int x) 
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return MINV;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return treap::query_prev(&amp;node-&gt;root, x);
		else
			return std::max(query_prev(node-&gt;lson, l, r, x), query_prev(node-&gt;rson, l, r, x));
	}

	int query_next(Node *node, int l, int r, int x) 
	{
		if(node-&gt;r &lt; l || node-&gt;l &gt; r) return MAXV;
		else if(l &lt;= node-&gt;l &amp;&amp; node-&gt;r &lt;= r)
			return treap::query_next(&amp;node-&gt;root, x);
		else
			return std::min(query_next(node-&gt;lson, l, r, x), query_next(node-&gt;rson, l, r, x));
	}

	void modify(Node *node, int pos, int x, int old)
	{
		treap::insert(&amp;node-&gt;root, x);
		treap::erase(&amp;node-&gt;root, old);

		if(node-&gt;l != node-&gt;r)
		{
			if(pos &lt;= ((node-&gt;l + node-&gt;r) &gt;&gt; 1))
				modify(node-&gt;lson, pos, x, old);
			else modify(node-&gt;rson, pos, x, old);

			pushup(node);
		}
		else
			node-&gt;rmax = node-&gt;rmin = x;
	}
}

int main()
{
	int n, m;
	scanf(&quot;%d&quot;, &amp;n); scanf(&quot;%d&quot;, &amp;m);
	for(int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, arr + i);
	seg::build_tree(1, n);

	int opt, l, r, k, pos;
	while(m --)
	{
		scanf(&quot;%d&quot;, &amp;opt);
		if(opt == 1)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_rank(seg::segroot, l, r, k) + 1);
		}
		else if(opt == 2)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_kth(l, r, k));
		}
		else if(opt == 3)
		{
			scanf(&quot;%d%d&quot;, &amp;pos, &amp;k);
			seg::modify(seg::segroot, pos, k, arr[pos]);
			arr[pos] = k;
		}
		else if(opt == 4)
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_prev(seg::segroot, l, r, k));
		}
		else
		{
			scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
			printf(&quot;%d\n&quot;, seg::query_next(seg::segroot, l, r, k));
		}
	}

	return 0;
}
</code></pre>
    </div>

    
    

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/%E6%A0%91%E5%A5%97%E6%A0%91/">树套树</a>
          
          <a href="/tags/splay/">splay</a>
          
          <a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/">线段树</a>
          
          <a href="/tags/vector/">vector</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/big_pow/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">计算3的1000000次方</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/wenbenbianjiqi-editor/">
            <span class="next-text nav-default">文本编辑器editor(splay)</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:y13916619121@126.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/AdamYuan" class="iconfont icon-github" title="github"></a>
  <a href="https://adamyuan.xyz/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">AdamYuan</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>
  <script type="text/javascript">
    window.MathJax = {
      showProcessingMessages: false,
      messageStyle: 'none'
    };
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-122304331-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
