<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.71.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>poj2104静态区间第k大(主席树)&nbsp;&ndash;&nbsp;AdamYuan-&gt;Blog</title><link rel="stylesheet" href="/css/core.min.3fe8a923744e0b66d5312f4346f30c05a93da06d4e65dc0a31c44e27e711d48f55b00fcece6d049f934672a81631dcdf.css" integrity="sha384-P&#43;ipI3ROC2bVMS9DRvMMBak9oG1OZdwKMcROJ&#43;cR1I9VsA/Ozm0En5NGcqgWMdzf"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="poj2104静态区间第k大(主席树)" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">AdamYuan->Blog</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">poj2104静态区间第k大(主席树)</h1><p class="article date">2018-08-30</p></section><article class="article markdown-body"><h1 id="题目概述">题目概述</h1>
<p>给定一个数列(1 - 100000)，m次询问(1 - 5000)，每个询问包含l r k，输出区间[l&hellip;r]中第k大的数。</p>
<h1 id="基本思路">基本思路</h1>
<p>首先我们将数列离散化。如果可以构造出任意区间的权值线段树(即线段树的下标代表区间中包含的数的值，例如数列1, 2, 2, 2, 3, 3, 4构成的权值线段树最下层为1, 3, 2, 1)，便能轻松二分出答案，同时区间[l&hellip;r]的权值线段树可以由区间[1&hellip;r]线段树中的值减去[1&hellip;l-1]得到，所以想到构造n颗前缀权值线段树。<br>
不过暴力建树空间复杂度太大，必然会mle，这时就需要用到主席树了。</p>
<h1 id="主席树">主席树</h1>
<p>主席树是一种可持久化数据结构(即可以获取所有历史版本)。由于线段树更新时只会使一条链上的值发生改变，于是可以直接新增一条链作为改动过后的版本，减小了空间开销，详细可见http://www.cnblogs.com/zyf0163/p/4749042.html1<br>
在这道题中，需要先建立一颗空的线段树(所有节点都为0)，然后将数列中的值一个接一个地添加到权值线段树中，理由主席树的特点便能轻松给出表示区间[1&hellip;i]的权值线段树。</p>
<h1 id="代码">代码</h1>
<div class="highlight"><pre class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;cstdio&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define N 100005
</span><span class="cp"></span>
<span class="k">struct</span> <span class="nc">Node</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">lson</span><span class="p">,</span> <span class="o">*</span><span class="n">rson</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Node</span> <span class="n">tree</span><span class="p">[</span><span class="n">N</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">];</span>
<span class="n">Node</span> <span class="o">*</span><span class="n">roots</span><span class="p">[</span><span class="n">N</span><span class="p">];</span> <span class="c1">//所有前缀线段树的根节点
</span><span class="c1"></span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kr">inline</span> <span class="n">Node</span> <span class="o">*</span><span class="nf">new_node</span><span class="p">()</span> <span class="p">{</span> <span class="k">static</span> <span class="n">Node</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">tree</span><span class="p">;</span> <span class="k">return</span> <span class="n">t</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>

<span class="n">Node</span> <span class="o">*</span><span class="nf">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="c1">//构建空树，返回根节点
</span><span class="c1"></span><span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">();</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">r</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">lson</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">rson</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Node</span> <span class="o">*</span><span class="nf">update</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">)</span> <span class="c1">//在pos处+1，返回更新后的根节点
</span><span class="c1"></span><span class="p">{</span>
	<span class="n">Node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">();</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">r</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="o">&lt;=</span> <span class="n">mid</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">lson</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">lson</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">rson</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rson</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">lson</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">lson</span><span class="p">;</span>
			<span class="n">current</span><span class="o">-&gt;</span><span class="n">rson</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rson</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">l_node</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span><span class="n">r_node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> 
		<span class="n">l_sum</span> <span class="o">=</span> <span class="n">r_node</span><span class="o">-&gt;</span><span class="n">lson</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">-</span> <span class="n">l_node</span><span class="o">-&gt;</span><span class="n">lson</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span> <span class="c1">//把两颗前缀线段树的值相减得到区间线段树上的值
</span><span class="c1"></span>
	<span class="k">if</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">l_sum</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">l_node</span><span class="o">-&gt;</span><span class="n">lson</span><span class="p">,</span> <span class="n">r_node</span><span class="o">-&gt;</span><span class="n">lson</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">l_node</span><span class="o">-&gt;</span><span class="n">rson</span><span class="p">,</span> <span class="n">r_node</span><span class="o">-&gt;</span><span class="n">rson</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">l_sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">arr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arr</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique</span><span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">tmp</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">build</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">lower_bound</span><span class="p">(</span><span class="n">tmp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">+</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">//离散化
</span><span class="c1"></span>		<span class="n">roots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">while</span><span class="p">(</span><span class="n">m</span> <span class="o">--</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">&#34;%d%d%d&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">tmp</span><span class="p">[</span><span class="n">query</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">roots</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">k</span><span class="p">)]);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></article><section class="article labels"><a class="category" href=/categories/oi/>OI</a><a class="tag" href=/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/>主席树</a><a class="tag" href=/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/>线段树</a></section><section class="article author"><img class="avatar" src="/img/avatar.png" alt><p class="name">AdamYuan</p><div class="details"><a class="item" href="https://github.com/AdamYuan" target="_blank"><span class="iconfont icon-github"></span>&nbsp;AdamYuan</a><a class="item" href="mailto:y13916619121@126.com" target="_blank"><span class="iconfont icon-email"></span>&nbsp;y13916619121@126.com</a></div>
</section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/post/wenbenbianjiqi-editor/"><span class="iconfont icon-article"></span>文本编辑器editor(splay)</a></p><p><a class="link" href="/post/configurate_gvim/"><span class="iconfont icon-article"></span>配置GVim</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2019 AdamYuan.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script></body>

</html>